# Ajusta Regressao
#'
#'
#' This function performs the training of the chosen regressor
#' @param df.train   Training dataframe
#' @param formula   A formula of the form y ~ x1 + x2 + ... If users don't inform formula, the first column will be used as Y values and the others columns with x1,x2....xn
#' @param preprocess pre process
#' @param regressor Choice of regressor to be used to train model. Uses  algortims names from Caret package.
#' @param nfolds     Number of folds to be build in crossvalidation
#' @param repeats repeats
#' @param index index
#' @param cpu_cores  Number of CPU cores to be used in parallel processing
#' @param tune_length  This argument is the number of levels for each tuning parameters that should be generated by train
#' @param metric metric used to evaluate model fit. For numeric outcome ("RMSE", "Rsquared)
#' @param seeds  seeds
#' @param verbose verbose
#' @keywords Train regression RMSE Rsquared
#' @importFrom parallel makePSOCKcluster stopCluster
#' @importFrom doParallel registerDoParallel
#' @importFrom caret trainControl train getTrainPerf
#' @importFrom stats as.formula
#' @author Elpidio Filho, \email{elpidio@ufv.br}
#' @details details
#' @export
#' @examples
#' \dontrun{
#' regression(df.train = df, regressor = "rf", metric = "Rsquared", seeds = 313)
#' }


regression <- function(df.train,
                       formula = NULL,
                       preprocess = NULL,
                       regressor = "rf",
                       nfolds = 10,
                       repeats =  NA,
                       index = NULL,
                       cpu_cores = 3,
                       tune_length = 5,
                       metric = "Rsquared",
                       seeds = NULL,
                       verbose = FALSE) {
  # library(doParallel)
  # library(caret)
  if (nfolds == 0) {
    method <- "none"
    tune_length <- NULL
  }
  if (nfolds >= nrow(df.train)) {
    method <- "LOOCV"
  } else {
    method <- "cv"
  }
  if (is.na(repeats) == FALSE) {
    if(repeats > 1) method <- "repeatedcv"
  }
  #tune_length = ifelse(tune_length > (ncol(df.train) -2), (ncol(df.train) -2), tune_length)

  inicio <- Sys.time()
  # if (is.null(formula)) {
  #    formula <- as.formula(paste(names(df.train)[1], "~ ."))
  #  }
  tc <- caret::trainControl(
    method = method,
    number = nfolds,
    repeats = repeats,
    index = index,
#    savePredictions = "final",
#    returnResamp = "final",
    seeds = seeds
 #   verboseIter = FALSE
  )

  if (cpu_cores > 0) {
    cl <- parallel::makePSOCKcluster(cpu_cores)
    doParallel::registerDoParallel(cl)
    on.exit(stopCluster(cl))
  }

  if (is.null(formula)) {
    fit <- tryCatch({
      caret::train(
        x = df.train[,-1],
        y = df.train[,1],
        method = regressor,
        metric = metric,
        trControl = tc,
#        verbose = FALSE,
        tuneLength = tune_length,
        preProcess = preprocess
      )},
      error = function(e){NULL})
  } else {
    fit <- tryCatch({
      caret::train(
        formula,
        data = df.train,
        method = regressor,
        metric = metric,
        trControl = tc,
 #       verbose = FALSE,
        tuneLength = tune_length,
        preProcess = preprocess
      )},
      error = function(e){NULL})
  }

#  if (!is.null(cl)) {
#    parallel::stopCluster(cl)
#  }
  if (verbose == TRUE) {
    #  print(paste("time elapsed : ", hms_span(inicio, Sys.time())))
    #   print(caret::getTrainPerf(fit))
  }
  return(fit)
}
