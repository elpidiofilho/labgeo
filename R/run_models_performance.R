#' Run Models Performance
#'
#'
#' @title Run Models Performance
#' @description This function performs the summary of perfomance of models fitter by run_models function
#' @param fit.run.model list generated by function run_models
#' @param df.valida validation data frame
#' @param flagplot plot graphics of comparation between models
#' @details details
#' @importFrom caret postResample
#' @importFrom dplyr tibble
#' @importFrom ggplot2 ggplot
#' @importFrom ggplot2 geom_point
#' @importFrom ggplot2 ggtitle
#' @importFrom ggplot2 geom_abline
#' @importFrom ggplot2 xlim
#' @importFrom ggplot2 ylim
#' @importFrom ggplot2 aes
#' @importFrom viridis scale_color_viridis
#' @importFrom MASS kde2d
#' @examples
#' \dontrun{
#' library(dplyr)
#' vf = labgeo::factor_detect(c_stock, 40)
#' df = c_stock %>%  mutate_at(vf,funs(factor))
#' dp = data_preparation(df = df, p = 0.10, prune = 0.99)
#' treino = dp$treino
#' teste = dp$teste
#' nm = names(treino)[1]
#' vrf = recursive_feature_elimination(treino,sizes = c(5,10,15,20,25,30,40),
#'                                     nfolds = 5,cpu_cores = 7, metric = "Rsquared")
# 'vsel = c(nm,vrf$optVariables[1:30])
# 'dfsel = treino %>% select(one_of(vsel))
# 'models = c("ridge", "rf", "cubist","pls")
# 'fit_models = run_models(df = dfsel, models = models,
#'                         cpu_cores = 7, tune_length = 5, metric = "Rsquared")
# 'dfresult = run_models_performance(fit_models, df.valida = teste, flagplot = F)
# 'head(dfresult)
#' }
#' @export

run_models_performance <- function(fit.run.model, df.valida, flagplot = FALSE) {
  nm = length(fit.run.model)
  summ_model = dplyr::tibble(model = character(nm), fit = list(nm), dfpredobs = list(nm),
                      mbe = numeric(nm), mae = numeric(nm),
                       r2 = numeric(nm), rmse = numeric(nm), nse = numeric(nm),
                      var_exp = numeric(nm),
                      grafic1 = list(nm), grafic2 = list(nm))

  for (i in 1:length(fit.run.model)) {
    fit.md = fit.run.model[[i]]
    v = predict(fit.md, df.valida)
    ddd = data.frame(observado = df.valida[, 1], predito = v, residuo = abs(v - df.valida[,1]))
    names(ddd)[1] = "observado"
    names(ddd)[3] = "residuo"
    summ_model$model[i] = fit.md$method
    summ_model$fit[i] = list(fit.md)
    summ_model$dfpredobs[i] = list(ddd)
    acc = pred_acc(ddd$predito, ddd$observado)
    summ_model$r2[i] = acc$rsquared
    summ_model$rmse[i] = acc$root_mean_square_error
    summ_model$mbe[i] = acc$mean_bias_error
    summ_model$mae[i] = acc$mean_absolute_error
    summ_model$nse[i] = acc$Nash_Sutcliffe_efficiency
    summ_model$var_exp[i] = acc$variance_explained_perc
    maxvalue = ceiling(max(max(df.valida[, 1]), v) / 5) * 5
    summ_model$grafic1[i] = list(ggplot2::ggplot(ddd, aes(x= predito, y = observado)) +
                                   ggplot2::geom_point() +
                                   ggplot2::ggtitle(paste(fit.md$method, " R2 = ",
                                                 round(summ_model$r2[i], 3))) +
                                   ggplot2::xlim(c(0,maxvalue)) + ggplot2::ylim(c(0, maxvalue))+
                                   ggplot2::geom_abline(slope = 1, intercept = 0, color = "red"))

    residuo = ddd$residuo
    density <- get_density(ddd$predito, ddd$observado)
    maxresiduo = max(residuo)

    summ_model$grafic2[i] = list(ggplot2::ggplot(ddd) +
                                   ggplot2::geom_point(aes(predito, observado, color = density ^ 0.7), size = 0.1, shape = 20) +
                                   viridis::scale_color_viridis() +
                                   ggplot2::xlim(c(0,maxvalue)) + ggplot2::ylim(c(0, maxvalue)) +
                                   ggplot2::geom_abline(slope = 1, intercept = 0, color = "red") +
                                   ggplot2::ggtitle(fit.md$method))

  }
  if (flagplot == TRUE) {
    dgr = summ_model %>% select(model, mbe, mae, rmse, nse, r2, var_exp) %>%
      tidyr::gather(key = var, value = valor, -model)
    print(ggplot2::ggplot(dgr, aes(x = model, y = valor, fill = model)) +
            ggplot2::geom_col() +
            ggplot2::geom_text(aes(label = round(valor,3)), size = 3, vjust=1.5) +
            ggplot2::facet_wrap(~var, scales = "free"))
  }
  return(summ_model)
}

get_density <- function(x, y, n = 100) {
  dens <- MASS::kde2d(x = x, y = y, n = n)
  ix <- findInterval(x, dens$x)
  iy <- findInterval(y, dens$y)
  ii <- cbind(ix, iy)
  return(dens$z[ii])
}

pred_acc <- function (obs, pred) {
  mu <- mean(obs)
  mbe <- mean(obs - pred)              ## mean bias error ()
  mae <- mean(abs(obs - pred))         ## mean absolute error
  mse <-  mean((obs - pred) ^ 2)       ## mean square error
  rme <- mbe / mu * 100                ## relative mean error
  rmae <- mae / mu * 100               ## relative mean absolute error
  rmse <- sqrt(mse)                    ## root mean square error
  rrmse <- rmse / mu * 100             ## relative root mean square error
  mo = mean((obs - mu) ^ 2)
  nse = 1 -  (mse / mo)                ## Nash-Sutcliffe efficiency
  r2 = cor(obs,pred) ^ 2
  t = t.test(obs,pred,paired=TRUE)
  vecv <- (1 - sum((obs - pred) ^ 2) /
             sum((obs - mean(obs)) ^ 2)) * 100 ## variance explained by predictive models

  list(mean_bias_error = mbe, relative_mean_bias_error = rme, mean_absolute_error = mae,
       relative_mean_absolute_error = rmae,  mean_square_error = mse, root_mean_square_error = rmse,
       relative_rmse = rrmse, Nash_Sutcliffe_efficiency  = nse, variance_explained_perc = vecv, rsquared = r2, t_test = list(t))
}


a = c()
